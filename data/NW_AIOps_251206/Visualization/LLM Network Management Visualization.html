<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM-Based Network Management Explorer</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Helvetica Neue', sans-serif; background-color: #f4f4f7; color: #333; }
        #root { width: 100vw; height: 100vh; }
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 40px;
            box-sizing: border-box;
        }
        .header {
            max-width: 600px;
            pointer-events: auto;
        }
        .header h1 {
            font-size: 2.5rem;
            font-weight: 300;
            margin: 0 0 10px 0;
            color: #1a1a2e;
            letter-spacing: -1px;
        }
        .header p {
            font-size: 1rem;
            color: #666;
            line-height: 1.5;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0,0,0,0.05);
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);
        }
        .card-container {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 400px;
            pointer-events: auto;
        }
        .info-card {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            border: 1px solid rgba(0,0,0,0.05);
            backdrop-filter: blur(20px);
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }
        .info-card.active {
            transform: translateY(0);
            opacity: 1;
        }
        .info-card h2 {
            margin: 0 0 15px 0;
            font-size: 1.8rem;
            color: #2c3e50;
        }
        .info-card h3 {
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            margin-bottom: 5px;
        }
        .info-card p {
            font-size: 1rem;
            line-height: 1.6;
            color: #444;
            margin-bottom: 20px;
        }
        .info-card ul {
            padding-left: 20px;
            margin: 0;
        }
        .info-card li {
            margin-bottom: 8px;
            color: #555;
        }
        .citation {
            font-size: 0.75rem;
            color: #999;
            margin-top: 15px;
            display: block;
            text-align: right;
            font-style: italic;
        }
        .instruction {
            position: absolute;
            bottom: 40px;
            left: 40px;
            color: #888;
            font-size: 0.9rem;
            background: rgba(255,255,255,0.6);
            padding: 10px 20px;
            border-radius: 30px;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Data derived solely from the provided PDF [Hong et al., 2025]
        const dataPoints = [
            {
                id: 'center',
                label: 'LLM Core',
                title: 'Large Language Models',
                category: 'Foundation',
                description: 'LLMs serve as the intelligent core, interpreting natural language intents to automate complex network operations. They process unstructured text data (logs, manuals) to generate policies.',
                details: [
                    'Interprets abstract intents [cite: 18]',
                    'Automates complex tasks [cite: 42]',
                    'Utilizes Fine-tuning & RAG [cite: 231]'
                ],
                citation: 'Hong et al., Int J Network Mgmt 2025 [cite: 16, 41]'
            },
            {
                id: 'design',
                label: 'Design',
                title: 'Network Design',
                category: 'Planning',
                description: 'LLMs generate optimal topologies and architectures based on user requirements. They analyze standards (3GPP, IEEE) to guide design decisions.',
                details: [
                    'Input: "Create a scalable Leaf-Spine topology" [cite: 301]',
                    'Output: Topology blueprints & stability analysis [cite: 303]',
                    'Extracts protocols from RFC documents [cite: 632]'
                ],
                citation: '[cite: 57, 364, 371]'
            },
            {
                id: 'config',
                label: 'Configuration',
                title: 'Configuration',
                category: 'Operations',
                description: 'Transforms high-level intents into low-level device commands (BGP, ACLs) across heterogeneous devices, reducing manual errors.',
                details: [
                    'Translates intent to CLI/Scripts [cite: 396]',
                    'Example: "Block YouTube traffic" -> ACL rules [cite: 43]',
                    'Supports multi-vendor environments [cite: 390]'
                ],
                citation: '[cite: 396, 398]'
            },
            {
                id: 'fault',
                label: 'Fault Mgmt',
                title: 'Fault Management',
                category: 'Maintenance',
                description: 'Monitors logs and events to detect anomalies and perform root-cause analysis. It can predict failures before they occur.',
                details: [
                    'Parses unstructured logs (syslog) [cite: 46]',
                    'Detects "link down" patterns & suggests fixes [cite: 48, 313]',
                    'Reduces time for diagnosis [cite: 478]'
                ],
                citation: '[cite: 467, 472]'
            },
            {
                id: 'security',
                label: 'Security',
                title: 'Network Security',
                category: 'Protection',
                description: 'Analyzes traffic patterns and security logs to identify threats like DDoS attacks or intrusions, often outperforming rule-based systems.',
                details: [
                    'Detects UDP Flooding & anomalies [cite: 318]',
                    'Interprets ambiguous "suspicious traffic" [cite: 502]',
                    'Generates immediate mitigation policies [cite: 48]'
                ],
                citation: '[cite: 491, 502]'
            },
            {
                id: 'orchestration',
                label: 'Orchestration',
                title: 'Orchestration',
                category: 'Automation',
                description: 'Integrates operational data for autonomous decision-making, such as auto-scaling resources based on traffic load.',
                details: [
                    'Dynamic Resource Optimization [cite: 321]',
                    'Lifecycle management (scale-out/in) [cite: 518]',
                    'Closed-loop feedback for self-healing [cite: 530]'
                ],
                citation: '[cite: 508, 521]'
            }
        ];

        const App = () => {
            const mountRef = useRef(null);
            const [activeNode, setActiveNode] = useState(dataPoints[0]);
            const [hoveredNode, setHoveredNode] = useState(null);

            useEffect(() => {
                const width = window.innerWidth;
                const height = window.innerHeight;

                // Scene Setup
                const scene = new THREE.Scene();
                scene.background = new THREE.Color('#f4f4f7');
                scene.fog = new THREE.Fog('#f4f4f7', 10, 50);

                // Camera
                const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
                camera.position.set(0, 0, 18);

                // Renderer
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.shadowMap.enabled = true;
                mountRef.current.appendChild(renderer.domElement);

                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                scene.add(ambientLight);

                const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
                dirLight.position.set(10, 10, 10);
                dirLight.castShadow = true;
                scene.add(dirLight);

                const pointLight = new THREE.PointLight(0x3498db, 1, 50);
                pointLight.position.set(0, 0, 5);
                scene.add(pointLight);

                // Group
                const networkGroup = new THREE.Group();
                scene.add(networkGroup);

                // Materials
                const coreMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0x2980b9,
                    metalness: 0.2,
                    roughness: 0.1,
                    transparent: true,
                    opacity: 0.9,
                    transmission: 0.2,
                    clearcoat: 1.0
                });

                const satelliteMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0xffffff,
                    metalness: 0.1,
                    roughness: 0.2,
                    clearcoat: 0.8
                });

                const hoverMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0xe74c3c,
                    metalness: 0.3,
                    roughness: 0.2
                });

                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0xbdc3c7,
                    transparent: true,
                    opacity: 0.4
                });

                // Geometry
                const sphereGeo = new THREE.IcosahedronGeometry(1, 1);
                const smallSphereGeo = new THREE.IcosahedronGeometry(0.6, 0);

                // Create Nodes
                const nodes = [];
                const radius = 6;
                
                // Central Node (LLM)
                const centerNode = new THREE.Mesh(new THREE.IcosahedronGeometry(1.5, 2), coreMaterial);
                centerNode.userData = { id: 'center', originalPos: new THREE.Vector3(0,0,0) };
                networkGroup.add(centerNode);
                nodes.push(centerNode);

                // Satellite Nodes
                const satellites = dataPoints.filter(d => d.id !== 'center');
                satellites.forEach((item, i) => {
                    const angle = (i / satellites.length) * Math.PI * 2;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    
                    const node = new THREE.Mesh(smallSphereGeo, satelliteMaterial.clone());
                    node.position.set(x, y, 0);
                    node.userData = { id: item.id, originalPos: new THREE.Vector3(x, y, 0) };
                    
                    networkGroup.add(node);
                    nodes.push(node);

                    // Connection Line
                    const points = [new THREE.Vector3(0,0,0), new THREE.Vector3(x, y, 0)];
                    const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(lineGeo, lineMaterial);
                    networkGroup.add(line);

                    // Floating text label
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 256;
                    canvas.height = 64;
                    ctx.font = 'bold 24px Arial';
                    ctx.fillStyle = '#2c3e50';
                    ctx.textAlign = 'center';
                    ctx.fillText(item.label, 128, 40);
                    const texture = new THREE.CanvasTexture(canvas);
                    const spriteMat = new THREE.SpriteMaterial({ map: texture });
                    const sprite = new THREE.Sprite(spriteMat);
                    sprite.position.set(x, y - 1.2, 0);
                    sprite.scale.set(4, 1, 1);
                    networkGroup.add(sprite);
                });

                // Particles
                const particleCount = 100;
                const particleGeo = new THREE.BufferGeometry();
                const particlePos = new Float32Array(particleCount * 3);
                
                for(let i=0; i<particleCount; i++) {
                    particlePos[i*3] = (Math.random() - 0.5) * 20;
                    particlePos[i*3+1] = (Math.random() - 0.5) * 20;
                    particlePos[i*3+2] = (Math.random() - 0.5) * 10;
                }
                particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePos, 3));
                const particleMat = new THREE.PointsMaterial({ color: 0xbdc3c7, size: 0.05 });
                const particles = new THREE.Points(particleGeo, particleMat);
                scene.add(particles);

                // Interaction
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();

                const onMouseMove = (event) => {
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                };

                const onClick = () => {
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(nodes);
                    if (intersects.length > 0) {
                        const id = intersects[0].object.userData.id;
                        const data = dataPoints.find(d => d.id === id);
                        if (data) setActiveNode(data);
                    }
                };

                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('click', onClick);

                // Animation Loop
                const animate = () => {
                    requestAnimationFrame(animate);

                    // Rotation
                    networkGroup.rotation.y += 0.002;
                    particles.rotation.y -= 0.001;

                    // Hover effect
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(nodes);

                    nodes.forEach(node => {
                        // Pulse effect
                        const time = Date.now() * 0.001;
                        if (node.userData.id === 'center') {
                            node.scale.setScalar(1 + Math.sin(time) * 0.05);
                        } else {
                            // Float effect
                            node.position.y = node.userData.originalPos.y + Math.sin(time + node.position.x) * 0.2;
                        }

                        if (intersects.length > 0 && intersects[0].object === node) {
                            node.material.color.setHex(0x3498db);
                            node.scale.setScalar(node.userData.id === 'center' ? 1.6 : 1.2);
                            document.body.style.cursor = 'pointer';
                        } else {
                            node.material.color.setHex(node.userData.id === 'center' ? 0x2980b9 : 0xffffff);
                            if (node.userData.id !== 'center') node.scale.setScalar(1);
                            if (intersects.length === 0) document.body.style.cursor = 'default';
                        }
                    });

                    renderer.render(scene, camera);
                };

                animate();

                // Cleanup
                return () => {
                    if (mountRef.current) mountRef.current.removeChild(renderer.domElement);
                    window.removeEventListener('mousemove', onMouseMove);
                    window.removeEventListener('click', onClick);
                };
            }, []);

            return (
                <div>
                    <div ref={mountRef} />
                    <div className="ui-layer">
                        <div className="header">
                            <h1>LLM-Based Network Management</h1>
                            <p>
                                A comprehensive survey of how Large Language Models (LLMs) are transforming 
                                network operations from manual rule-based methods to AI-driven paradigms.
                                <br/><br/>
                                <small>Source: Hong et al., Int J Network Mgmt 2025</small>
                            </p>
                        </div>
                        
                        <div className="instruction">
                            Click on the nodes to explore key network domains
                        </div>

                        <div className={`card-container`}>
                            <div className={`info-card ${activeNode ? 'active' : ''}`}>
                                <h3>{activeNode.category}</h3>
                                <h2>{activeNode.title}</h2>
                                <p>{activeNode.description}</p>
                                <ul>
                                    {activeNode.details.map((detail, idx) => (
                                        <li key={idx}>{detail}</li>
                                    ))}
                                </ul>
                                <span className="citation">Ref: {activeNode.citation}</span>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>